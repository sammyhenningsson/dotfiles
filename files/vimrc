" Auto-install vim-plug
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif

call plug#begin()
"Language pack
Plug 'sheerun/vim-polyglot'

" Unix shell commands
Plug 'tpope/vim-eunuch'

"Universal defaults
Plug 'tpope/vim-sensible'

"Adjust shiftwidth and expandtab
Plug 'tpope/vim-sleuth'

"Git
Plug 'tpope/vim-fugitive'

"Rails
Plug 'tpope/vim-rails'

"Toggle comments
Plug 'tpope/vim-commentary'

"Change surrounding chars of a word
Plug 'tpope/vim-surround'

"Syntax check
" Plug 'scrooloose/syntastic'
Plug 'w0rp/ale'

"File browser
"Plug 'scrooloose/nerdtree'

"Color theme
Plug 'dracula/vim'

"Fuzzy file finder
"Plug 'ctrlpvim/ctrlp.vim'

"Rspec
Plug 'thoughtbot/vim-rspec'

"Split/join statements
Plug 'AndrewRadev/splitjoin.vim'

"Paste without losing yanked text
"Plug 'vim-scripts/ReplaceWithRegister'

"Jump between lines depending on indentation
Plug 'jeetsukumaran/vim-indentwise'

"Solarized color scheme
Plug 'altercation/vim-colors-solarized'

call plug#end()

" enable all features
set nocompatible

" Wrap too long lines
set wrap

" Tabs are 4 characters
set tabstop=4
set softtabstop=4

" (Auto)indent uses 4 characters
set shiftwidth=4

" spaces instead of tabs
set expandtab

set pastetoggle=<C-u>
set showmode

" guess indentation
set autoindent

" Expand the command line using tab
set wildchar=<Tab>
set wildcharm=<Tab>

" show line numbers
"set number

" powerful backspaces
set backspace=indent,eol,start

" highlight the searchterms
set hlsearch

" jump to the matches while typing
set incsearch

" ignore case while searching
set ignorecase

" don't wrap words
set textwidth=0

" history
set history=50

" 1000 undo levels
set undolevels=1000

" show partial commands
set showcmd

" show matching braces
set showmatch

" write before hiding a buffer
set autowrite

" auto-detect the filetype
filetype plugin indent on

" syntax highlight
syntax on

"Ignore case
set ic

" Smartcase search. If any character is a Capital, search is case sensitive
set scs

" we use a dark background, don't we?
"set bg=dark

" Always show the menu, insert longest match
set completeopt=menuone,longest

"Open new buffers in a new tab
" set switchbuf=usetab,newtab

" Search recursive (e.g. :find SOME_FI <TAB>)
set path+=**

" Exculde node_modules/ for search, like :find or :tabfind
set wildignore+=*/node_modules/*

"
set clipboard=unnamedplus

"
set splitbelow
set splitright

" Create session files
set sessionoptions=buffers,curdir,folds,tabpages

autocmd FileType html setlocal sw=2 sts=2 et
autocmd FileType ruby setlocal sw=2 sts=2 et suffixesadd+=.rb
autocmd FileType eruby setlocal sw=2 sts=2 et
" autocmd FileType yaml setlocal foldmethod=indent

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g`\"" |
  \ endif

autocmd BufEnter * stopinsert

" Disable paste mode when leaving Insert Mode
autocmd InsertLeave * set nopaste

let mapleader = ','
nnoremap <leader>p :!ruby -c %<CR>
nnoremap <leader>c :call g:ToggleQuickfix()<CR>
nnoremap <leader>n :set number!<CR>
nnoremap <leader>rh :set cursorline!<CR>
nnoremap <leader>b f,2lXi<CR><Esc>
nnoremap <leader>d :call RailsDbSchema()<CR>
nnoremap <leader>q :call RailsRoutes()<CR>
nnoremap <leader>l :call g:ToggleColorColumn()<CR>
nnoremap <leader>g yiw:Ggrep <C-R>"<CR>
vmap     <leader>g y:Ggrep <C-R>"<CR>
" map      <leader>d :redraw!<CR>
nnoremap <leader>rts 'T:call RunNearestSpec()<CR>

" Open file relative to current file
nnoremap <leader>e :e <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>t :tabe <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>s :split <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>v :vsplit <C-R>=expand("%:p:h") . "/" <CR>
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'


" Rspec
nnoremap <leader>rf :call RunCurrentSpecFile()<CR>
nnoremap <leader>rs :call RunNearestSpec()<CR>
nnoremap <leader>rl :call RunLastSpec()<CR>
nnoremap <leader>ra :call RunFailedSpecs()<CR>


" Change current directory to the same as current file
" set autochdir
" autocmd BufEnter * silent! lcd %:p:h

"Ctags
set tags+=./.ctags,.git/tags
"Open the definition in a new tab
nnoremap <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
"Open the definition in a vertical split
nnoremap <A-\> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

"Map gl to Go to end of line
nnoremap gl $
nnoremap gh ^

"Map Ctrl h/l to previous/next tab
map <C-h> :tabp<CR>
map <C-l> :tabn<CR>

exec "set <A-H>=\eh"
exec "set <A-J>=\ej"
exec "set <A-K>=\ek"
exec "set <A-L>=\el"
exec "nmap \eh <A-H>"
exec "nmap \ej <A-J>"
exec "nmap \ek <A-K>"
exec "nmap \el <A-L>"
nmap <A-H> 3b
nmap <A-J> 5j
nmap <A-K> 5k
nmap <A-L> 3w

"" in visual mode, search selection up or down
vnoremap * y/<C-R>"<CR>
vnoremap # y?<C-R>"<CR>

cmap w!! w !sudo tee > /dev/null %

function! g:ToggleQuickfix()
  for buffer in tabpagebuflist()
    if bufname(buffer) == ''
      " then it should be the quickfix window
      cclose
      return
    endif
  endfor

  copen
endfunction

function! g:ToggleColorColumn()
  if &l:colorcolumn != ''
    let &l:colorcolumn=''
  else
    let &l:colorcolumn=col('.')
  endif
endfunction

function! RailsDbSchema()
  let l:git_dir = system("git rev-parse --show-toplevel")
  let l:file = substitute(l:git_dir, '\n$', '', '') . "/db/schema.rb"
  :exec("0tabedit ".expand(l:file))
endfunction

function! RailsRoutes()
  let l:git_dir = system("git rev-parse --show-toplevel")
  let l:file = substitute(l:git_dir, '\n$', '', '') . "/config/routes.rb"
  :exec("0tabedit ".expand(l:file))
endfunction

function! BufSel(pattern)
  let bufcount = bufnr("$")
  let currbufnr = 1
  let nummatches = 0
  let firstmatchingbufnr = 0
  while currbufnr <= bufcount
    if(bufexists(currbufnr))
      let currbufname = bufname(currbufnr)
      if(match(currbufname, a:pattern) > -1)
        echo currbufnr . ": ". bufname(currbufnr)
        let nummatches += 1
        let firstmatchingbufnr = currbufnr
      endif
    endif
    let currbufnr = currbufnr + 1
  endwhile
  if(nummatches == 1)
    execute ":buffer ". firstmatchingbufnr
  elseif(nummatches > 1)
    let desiredbufnr = input("Enter buffer number: ")
    if(strlen(desiredbufnr) != 0)
      execute ":buffer ". desiredbufnr
    endif
  else
    echo "No matching buffers"
  endif
endfunction

" Make sure highlight search foreground color is displayable on Yellow
highlight Search term=reverse ctermbg=11 ctermfg=Black guibg=Yellow

" Code Lint
" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_auto_loc_list = 2
" let g:syntastic_check_on_open = 1
" let g:syntastic_check_on_wq = 0
" let g:syntastic_ruby_checkers = ['rubocop']
" let g:syntastic_javascript_checkers = ['eslint']
" let g:syntastic_javascript_eslint_exe = '$(npm bin)/eslint'
" let g:syntastic_scss_checkers = ['scss_lint']
" let g:syntastic_debug = 33
"let g:syntastic_loc_list_height = 3

let g:ale_set_highlights = 0

let g:solarized_termcolors=256
set background=dark
colorscheme solarized

" if &diff
"   highlight DiffAdd    cterm=BOLD ctermfg=NONE ctermbg=22
"   highlight DiffDelete cterm=BOLD ctermfg=NONE ctermbg=52
"   highlight DiffChange cterm=BOLD ctermfg=NONE ctermbg=23
"   highlight DiffText   cterm=BOLD ctermfg=NONE ctermbg=24
" endif

" Added git branch to status line
set statusline=%<%{fugitive#statusline()}\ 
set statusline+=%f\ 
set statusline+=%h%m%r
set statusline+=%q
set statusline+=[Buf:%n]
set statusline+=%=
set statusline+=%-14.(%l,%c%V%)\ 
set statusline+=%P


" Fix for weird characters???
"autocmd VimEnter,InsertLeave * silent execute '!echo -ne "\e[2 q"' | redraw!
"autocmd InsertEnter,InsertChange *
"  \ if v:insertmode == 'i' | 
"  \   silent execute '!echo -ne "\e[6 q"' | redraw! |
"  \ elseif v:insertmode == 'r' |
"  \   silent execute '!echo -ne "\e[4 q"' | redraw! |
"  \ endif
"autocmd VimLeave * silent execute '!echo -ne "\e[ q"' | redraw!

function! BufSel(pattern)
  let bufcount = bufnr("$")
  let currbufnr = 1
  let nummatches = 0
  let firstmatchingbufnr = 0
  while currbufnr <= bufcount
    if(bufexists(currbufnr))
      let currbufname = bufname(currbufnr)
      if(match(currbufname, a:pattern) > -1)
        echo currbufnr . ": ". bufname(currbufnr)
        let nummatches += 1
        let firstmatchingbufnr = currbufnr
      endif
    endif
    let currbufnr = currbufnr + 1
  endwhile

  if(nummatches == 1)
    return firstmatchingbufnr
  elseif(nummatches > 1)
    let desiredbufnr = input("Enter buffer number: ")
    if(strlen(desiredbufnr) != 0)
      return desiredbufnr
    endif
  else
    return -1
  endif
endfunction

function! BufOpen(pattern)
  let matchnr = BufSel(a:pattern)
  if(matchnr < 0)
    echo "No buffers match: " . a:pattern
  else
    execute ":buffer ". matchnr
  endif
endfunction

function! BufTabOpen(pattern)
  let matchnr = BufSel(a:pattern)
  if(matchnr < 0)
    echo "No buffers match: " . a:pattern
  else
    execute ":tab sb ". matchnr
  endif
endfunction

"Bind the Buf**() functions to user-commands
command! -nargs=1 Bs :call BufSel("<args>")
command! -nargs=1 Bo :call BufOpen("<args>")
command! -nargs=1 Bt :call BufTabOpen("<args>")
